# -*- coding: utf-8 -*-
"""Nowlan CIS 521 HW 3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MfLFK7nYW5WY7MSY9LHvB66_GH-ArKOu
"""

############################################################
# CIS 521: Homework 3
############################################################

student_name = "Marcus Nowlan"

############################################################
# Imports
############################################################

# Include your imports here, if any are used.
import random
import queue


############################################################
# Section 1: Tile Puzzle
# The Tile Puzzle is a puzzle on an m x n grid, where each
# tile is numbered from 0 to m*n-1 (1 being the first tile, 2
# being the second,..., and 0 being the m*n-1-th tile). The
# tiles are placed in a random order, and the goal is to put
# the tiles back in correct order. The only way to change the
# grid is to swap the 0 tile with one of its neighboring tiles.
# For example, [[1,4,3],[5,7,8],[2,0,6]] would be a valid move
# from a puzzle [[1,4,3],[5,7,8],[0,2,6]], and the solution to
# that same puzzle would be [[1,2,3],[4,5,6],[7,8,0]]. Here,
# create_tile_puzzle(rows, cols) creates a new TilePuzzle
# instance with the specified number of rows and columns, and
# TilePuzzle.find_solution_a_star() uses an A* search
# (using the total Manhattan distance between the board state
# and solution as a heuristic) to find an optimal solution
# (fewest moves required) to solve the puzzle, and outputs
# the solution as a list of strings ('up', 'down', 'left',
# or 'right') representing the moves taken to solve it. You
# can visualize this using the other file provided by running
# python3 homework3_tile_puzzle_gui.py rows cols in terminal,
# where rows and cols are positive integer values representing
# the rows and columns in the puzzle to be solved.
############################################################

def create_tile_puzzle(rows, cols):
    b = []
    for i in range(rows):
      b.append([])
      for j in range(cols):
        b[i].append(i*cols+j+1)
    b[rows-1][cols-1] = 0
    return TilePuzzle(b)

class TilePuzzle(object):
    
    def __lt__(self, other):
      return self.get_board()[0][0] < other.get_board()[0][0]
    
    # Required
    def __init__(self, board):
        self.board = board
        self.rows = len(self.board)
        self.cols = 0
        self.empty = (0,0)
        if len(board) > 0:
          self.cols = len(board[0])
          for i in range(len(board)):
            for j in range(len(board[0])):
              if board[i][j] == 0:
                self.empty = (i,j)

    def get_board(self):
        return self.board

    def perform_move(self, direction):
        if direction == "up":
          if self.empty[0] != 0:
            self.board[self.empty[0]][self.empty[1]] = self.board[self.empty[0] - 1][self.empty[1]]
            self.board[self.empty[0] - 1][self.empty[1]] = 0
            self.empty = (self.empty[0] - 1, self.empty[1])
            return True
        if direction == "down":
          if self.empty[0] != self.cols-1:
            self.board[self.empty[0]][self.empty[1]] = self.board[self.empty[0] + 1][self.empty[1]]
            self.board[self.empty[0] + 1][self.empty[1]] = 0
            self.empty = (self.empty[0] + 1, self.empty[1])
            return True
        if direction == "left":
          if self.empty[1] != 0:
            self.board[self.empty[0]][self.empty[1]] = self.board[self.empty[0]][self.empty[1]-1]
            self.board[self.empty[0]][self.empty[1]-1] = 0
            self.empty = (self.empty[0], self.empty[1]-1)
            return True
        if direction == "right":
          if self.empty[1] != self.rows-1:
            self.board[self.empty[0]][self.empty[1]] = self.board[self.empty[0]][self.empty[1]+1]
            self.board[self.empty[0]][self.empty[1]+1] = 0
            self.empty = (self.empty[0], self.empty[1]+1)
            return True
        return False

    def scramble(self, num_moves):
        for i in range(num_moves):
          perform_move(random.choice(["up", "down", "left", "right"]))

    def is_solved(self):
        for i in range(self.rows):
          for j in range(self.cols):
            if (i+1)*(j+1) != self.rows*self.cols:
              if self.board[i][j] != i*self.cols+j+1:
                return False
        return True

    def copy(self):
        b = [None] * self.rows
        for i in range(self.rows):
          b[i] = self.board[i][:]
        return TilePuzzle(b)

    def successors(self):
        upCopy = self.copy()
        if upCopy.perform_move("up"):
          yield ("up", upCopy)
        downCopy = self.copy()
        if downCopy.perform_move("down"):
          yield ("down", downCopy)
        leftCopy = self.copy()
        if leftCopy.perform_move("left"):
          yield ("left", leftCopy)
        rightCopy = self.copy()
        if rightCopy.perform_move("right"):
          yield ("right", rightCopy)

    # Required
    def iddfs_helper(self, limit, moves):
      if limit == 0:
        if self.is_solved():
          yield moves
      elif limit == 1:
        for move, new_p in self.successors():
          if new_p.is_solved():
            yield moves + [move]
      else:
        for move, new_p in self.successors():
          c = new_p.copy()
          yield from c.iddfs_helper(limit-1, moves + [move])
    
    def find_solutions_iddfs(self):
        if self.is_solved():
          return []
        sols = []
        depth = 0
        while len(sols) == 0:
          for moves in self.iddfs_helper(depth,[]):
            if len(moves) > 0:
              sols.append(moves)
          depth += 1
        return sols

    # Required
    def manhattan_distance(self):
      ans = 0
      for i in range(self.rows):
        for j in range(self.cols):
          num = self.board[i][j] - 1
          if num < 0:
            num = self.rows * self.cols - 1
          soli = num / self.cols
          solj = num % self.cols
          ans = ans + abs(i - soli) + abs(j - solj)
      return ans
    
    def get_tuple(self):
      pre = []
      for i in range(len(self.board)):
        pre = pre + self.board[i][:]
      return tuple(pre)
      

    def find_solution_a_star(self):
        q = queue.PriorityQueue()
        visited = set()
        q.put((self.manhattan_distance(), self.copy().get_board(), []))
        while not q.empty():
          tup = q.get()
          tp = TilePuzzle(tup[1])
          if tp.is_solved():
            return tup[2]
          visited.add(tp.get_tuple())
          for move, new_p in tp.successors():
            if new_p.get_tuple() not in visited:
              t = TilePuzzle(new_p.get_board())
              q.put((len(tup[2]) + t.manhattan_distance(), t.get_board(), tup[2] + [move]))
        return None



############################################################
# Section 2: Grid Navigation
# In this section, the method find_path(start, goal, scene)
# outputs the quickest solution from a start location to a
# goal location in a maze. The maze is represented as a 2D
# list of Boolean values (False for open space that can be
# traveled through, True for walled space that cannot be
# traveled through). The output is a list of length-2 tuples,
# which are the locations on the maze traveled through to
# get from the start to the goal. Valid moves are up, down,
# left, right, up-left, up-right, down-left, and down-right
# (i.e. you can move diagonally and adjacently in the maze).
# An A* search algorithm is used again here, this time with
# the Euclidean distance being the heuristic. You can
# visualize the actions of this solver by running
# python3 homework3_grid_navigation_gui.py scene_path in terminal,
# where scene_path is a path to a test file corresponding to
# the layout of the maze. In the scene_path text files,
# "." characters correspond to empty spaces, and "X" characters
# correspond to wall spaces that cannot be traveled through.
############################################################

def find_path(start, goal, scene):
    cost_so_far = dict()
    came_from = dict()
    came_from[start] = None
    cost_so_far[start] = 0
    def euc(s):
      return ((s[0] - goal[0])**2 + (s[1] - goal[1])**2)**0.5
    
    def successors(curr):
      upOK = True
      downOK = True
      leftOK = True
      rightOK = True
      if curr[1] == 0:
        upOK = False
      if curr[1] == len(scene) - 1:
        downOK = False
      if curr[0] == 0:
        leftOK = False
      if curr[0] == len(scene[0]) - 1:
        rightOK = False
      if leftOK:
        # left:
        tm = (curr[0]-1, curr[1])
        new_cost = cost_so_far[curr] + 1
        if (tm not in cost_so_far or new_cost < cost_so_far[tm]) and scene[curr[0]-1][curr[1]] == False:
          cost_so_far[tm] = new_cost
          came_from[tm] = curr
          yield (new_cost + euc(tm), tm)
      if leftOK and upOK:
        # up-left:
        tm = (curr[0]-1, curr[1]-1)
        new_cost = cost_so_far[curr] + 2**0.5
        if (tm not in cost_so_far or new_cost < cost_so_far[tm]) and scene[curr[0]-1][curr[1]-1] == False:
          cost_so_far[tm] = new_cost
          came_from[tm] = curr
          yield (new_cost + euc(tm), tm)
      if leftOK and downOK:
        # down-left:
        tm = (curr[0]-1, curr[1]+1)
        new_cost = cost_so_far[curr] + 2**0.5
        if (tm not in cost_so_far or new_cost < cost_so_far[tm]) and scene[curr[0]-1][curr[1]+1] == False:
          cost_so_far[tm] = new_cost
          came_from[tm] = curr
          yield (new_cost + euc(tm), tm)
      if rightOK:
        # right:
        tm = (curr[0]+1, curr[1])
        new_cost = cost_so_far[curr] + 1
        if (tm not in cost_so_far or new_cost < cost_so_far[tm]) and scene[curr[0]+1][curr[1]] == False:
          cost_so_far[tm] = new_cost
          came_from[tm] = curr
          yield (new_cost + euc(tm), tm)
      if rightOK and upOK:
        # up-right: 
        tm = (curr[0]+1, curr[1]-1)
        new_cost = cost_so_far[curr] + 2**0.5
        if (tm not in cost_so_far or new_cost < cost_so_far[tm]) and scene[curr[0]+1][curr[1]-1] == False:
          cost_so_far[tm] = new_cost
          came_from[tm] = curr
          yield (new_cost + euc(tm), tm)
      if rightOK and downOK:
        # down-right:
        tm = (curr[0]+1, curr[1]+1)
        new_cost = cost_so_far[curr] + 2**0.5
        if (tm not in cost_so_far or new_cost < cost_so_far[tm]) and scene[curr[0]+1][curr[1]+1] == False:
          cost_so_far[tm] = new_cost
          came_from[tm] = curr
          yield (new_cost + euc(tm), tm)
      if downOK:
        # down:
        tm = (curr[0], curr[1]+1)
        new_cost = cost_so_far[curr] + 1
        if (tm not in cost_so_far or new_cost < cost_so_far[tm]) and scene[curr[0]][curr[1]+1] == False:
          cost_so_far[tm] = new_cost
          came_from[tm] = curr
          yield (new_cost + euc(tm), tm)
      if upOK:
        # up:
        tm = (curr[0], curr[1]-1)
        new_cost = cost_so_far[curr] + 1
        if (tm not in cost_so_far or new_cost < cost_so_far[tm]) and scene[curr[0]][curr[1]-1] == False:
          cost_so_far[tm] = new_cost
          came_from[tm] = curr
          yield (new_cost + euc(tm), tm)
    q = queue.PriorityQueue()
    q.put((0, start))
    while not q.empty():
      tup = q.get()
      if tup[1] == goal:
        break
      for s in successors(tup[1]):
        q.put(s)
    if goal in came_from:
      l = []
      l.append(goal)
      c = goal
      while came_from[c] is not None:
        l.append(came_from[c])
        c = came_from[c]
      return l[::-1]
    return None

############################################################
# Section 3: Linear Disk Movement, Revisited
# This section is about a puzzle, where there are a specified
# number of spaces in one row, and n distinct disks placed on
# these spaces, initially all on the left side of the board
# so the length - n right-most spaces are unfilled. The goal
# of this puzzle is to (1) move all the disks to the right
# side of the board completely, so that the length - n left-most
# spaces are unfilled and (2) reverse the original order of
# the disks. For example, if we represent each distinct disk
# as a positive integer, and each empty space as 0 on a list,
# a puzzle with length = 5 and n = 3 would originally look
# be [1,2,3,0,0] and its solution would be [0,0,3,2,1]. The
# only ways to move disks are to either (1) if there is an
# empty space adjacent to a disk, you can move the disk there
# or (2) if there is a disk adjacent to a disk, but the space
# 2 away from the disk is empty, a disk can "hop over" the disk
# next to it and fill the space 2 away. An example of the (1)
# occurring is if a puzzle moves from [1,2,3,0,0] to
# [1,2,0,3,0], and an example of (2) is if a puzzle moves from
# [1,2,0,3,0] to [0,2,1,3,0]. Note that moves in either direction
# are valid, so, for instance, going from [2,0,1,3] to [2,1,0,3]
# is valid. The method solve_distinct_disks(length, n) solves
# a puzzle of this type with length and n specified as integers,
# outputting the solution as a list of length-2 tuples
# representing the disk movements made. The method uses an
# A* search algorithm, with the sum of each disk's distance
# away from its goal position being the heuristic used.
############################################################

def solve_distinct_disks(length, n):
    sol = [0] * length
    for i in range(n):
      sol[length-i-1] = i+1
    solt = tuple(sol)
    def h(board):
      heuristic = 0
      for i in range(length):
        if board[i] != 0:
          heuristic = heuristic + abs(length - board[i] - i)
      return heuristic
    def successors(moves, board):
      for i in range(length):
        if board[i] > 0:
          if i < length - 1:
            if board[i+1] == 0:
              b = board[:]
              b[i+1] = b[i]
              b[i] = 0
              m = moves[:] + [(i,i+1)]
              yield (len(m) + h(b), m, b)
          if i < length - 2:
            if board[i+2] == 0 and board[i+1] > 0:
              b = board[:]
              b[i+2] = b[i]
              b[i] = 0
              m = moves[:] + [(i,i+2)]
              yield (len(m) + h(b), m, b)
          if i > 0:
            if board[i-1] == 0:
              b = board[:]
              b[i-1] = b[i]
              b[i] = 0
              m = moves[:] + [(i,i-1)]
              yield (len(m) + h(b), m, b)
          if i > 1:
            if board[i-2] == 0 and board[i-1] > 0:
              b = board[:]
              b[i-2] = b[i]
              b[i] = 0
              m = moves[:] + [(i,i-2)]
              yield (len(m) + h(b), m, b)
    q = queue.PriorityQueue()
    initialBoard = [0] * length
    for i in range(n):
      initialBoard[i] = i + 1
    q.put((h(initialBoard[:]), [], initialBoard[:]))
    while not q.empty():
      tup = q.get()
      if tuple(tup[2]) == solt:
        return tup[1]
      for s in successors(tup[1], tup[2]):
        q.put(s)
    return None
